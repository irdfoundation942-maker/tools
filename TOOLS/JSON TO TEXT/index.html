<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JSON to Text Parser | Advanced Converter Tool</title>
    <meta
      name="description"
      content="Convert JSON data to readable text format. Parse, view, and organize JSON content with ID-based navigation."
    />

    <!-- Favicon -->
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%236366f1'/%3E%3Ctext x='50' y='68' font-size='50' text-anchor='middle' fill='white' font-family='Arial, sans-serif' font-weight='bold'%3E%7B%7D%3C/text%3E%3C/svg%3E"
    />

    <!-- Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />

    <!-- SheetJS for Excel file reading -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

    <style>
      :root {
        --primary: #6366f1;
        --primary-hover: #4f46e5;
        --primary-light: rgba(99, 102, 241, 0.1);
        --secondary: #10b981;
        --secondary-light: rgba(16, 185, 129, 0.1);
        --accent: #f59e0b;
        --accent-light: rgba(245, 158, 11, 0.1);
        --danger: #ef4444;
        --danger-light: rgba(239, 68, 68, 0.1);

        --bg-dark: #0f172a;
        --bg-card: #1e293b;
        --bg-card-hover: #334155;
        --bg-input: #0f172a;

        --text-white: #f8fafc;
        --text-muted: #94a3b8;
        --text-dim: #64748b;

        --border: #334155;
        --border-light: #475569;

        --radius-sm: 6px;
        --radius-md: 10px;
        --radius-lg: 16px;
        --radius-xl: 24px;

        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
        --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.4);
        --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.5);
        --shadow-glow: 0 0 30px rgba(99, 102, 241, 0.3);
      }

      /* Light Theme */
      [data-theme="light"] {
        --bg-dark: #f1f5f9;
        --bg-card: #ffffff;
        --bg-card-hover: #f8fafc;
        --bg-input: #f8fafc;

        --text-white: #1e293b;
        --text-muted: #475569;
        --text-dim: #64748b;

        --border: #e2e8f0;
        --border-light: #cbd5e1;

        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.08);
        --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.1);
        --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.12);
        --shadow-glow: 0 0 30px rgba(99, 102, 241, 0.15);
      }

      [data-theme="light"] body::before {
        background: radial-gradient(
            ellipse at 20% 20%,
            rgba(99, 102, 241, 0.08) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 80% 80%,
            rgba(16, 185, 129, 0.06) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 50% 50%,
            rgba(245, 158, 11, 0.04) 0%,
            transparent 50%
          );
      }

      [data-theme="light"] .header {
        background: rgba(255, 255, 255, 0.8);
      }

      [data-theme="light"] .sidebar {
        background: rgba(255, 255, 255, 0.6);
      }

      [data-theme="light"] .logo-text h1 {
        background: linear-gradient(135deg, #1e293b, #475569);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      [data-theme="light"] .loading-overlay {
        background: rgba(241, 245, 249, 0.95);
      }

      [data-theme="light"] .loading-spinner {
        border-color: #e2e8f0;
        border-top-color: var(--primary);
      }

      /* Theme Toggle Button */
      .theme-toggle {
        width: 44px;
        height: 44px;
        border-radius: var(--radius-md);
        background: var(--bg-card);
        border: 1px solid var(--border);
        color: var(--text-white);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .theme-toggle:hover {
        background: var(--bg-card-hover);
        border-color: var(--border-light);
      }

      .theme-toggle svg {
        width: 20px;
        height: 20px;
      }

      .theme-toggle .sun-icon {
        display: none;
      }

      .theme-toggle .moon-icon {
        display: block;
      }

      [data-theme="light"] .theme-toggle .sun-icon {
        display: block;
      }

      [data-theme="light"] .theme-toggle .moon-icon {
        display: none;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
        background: var(--bg-dark);
        color: var(--text-white);
        min-height: 100vh;
        overflow-x: hidden;
      }

      /* Animated background gradient */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            ellipse at 20% 20%,
            rgba(99, 102, 241, 0.15) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 80% 80%,
            rgba(16, 185, 129, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 50% 50%,
            rgba(245, 158, 11, 0.05) 0%,
            transparent 50%
          );
        pointer-events: none;
        z-index: 0;
      }

      /* Header */
      .header {
        background: rgba(30, 41, 59, 0.8);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid var(--border);
        padding: 20px 40px;
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .header-content {
        max-width: 1980px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .logo-icon {
        width: 44px;
        height: 44px;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.4rem;
        box-shadow: var(--shadow-glow);
      }

      .logo-text h1 {
        font-size: 1.25rem;
        font-weight: 700;
        background: linear-gradient(
          135deg,
          var(--text-white),
          var(--text-muted)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .logo-text span {
        font-size: 0.75rem;
        color: var(--text-dim);
      }

      .header-actions {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      /* File Name Display */
      .file-name-display {
        display: none;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        color: var(--text-white);
        font-size: 14px;
        font-weight: 500;
        max-width: 300px;
        overflow: hidden;
      }

      .file-name-display.show {
        display: flex;
      }

      .file-name-display svg {
        width: 18px;
        height: 18px;
        color: var(--secondary);
        flex-shrink: 0;
      }

      .file-name-text {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: var(--text-white);
      }

      /* Main Layout */
      .main-container {
        display: flex;
        min-height: calc(100vh - 85px);
        position: relative;
        z-index: 1;
      }

      /* Sidebar - ID List */
      .sidebar {
        width: 340px;
        background: rgba(30, 41, 59, 0.6);
        backdrop-filter: blur(10px);
        border-right: 1px solid var(--border);
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        overflow-y: auto;
        max-height: calc(100vh - 85px);
      }

      .sidebar-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border);
      }

      .sidebar-title {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .id-count {
        background: var(--primary-light);
        color: var(--primary);
        padding: 4px 10px;
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
      }

      .id-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        flex: 1;
        overflow-y: auto;
      }

      .id-item {
        padding: 14px 16px;
        background: var(--bg-card);
        border: 1px solid transparent;
        border-radius: var(--radius-md);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .id-item:hover {
        background: var(--bg-card-hover);
        border-color: var(--border-light);
        transform: translateX(4px);
      }

      .id-item.active {
        background: var(--primary-light);
        border-color: var(--primary);
        box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
      }

      .id-item.active .id-number {
        background: var(--primary);
        color: white;
      }

      .id-number {
        width: 32px;
        height: 32px;
        background: var(--bg-input);
        border-radius: var(--radius-sm);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-muted);
      }

      .id-label {
        flex: 1;
        font-size: 0.875rem;
        color: var(--text-white);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* Content Area */
      .content-area {
        flex: 1;
        padding: 32px;
        display: flex;
        flex-direction: column;
        gap: 24px;
        overflow-y: auto;
        max-height: calc(100vh - 85px);
      }

      /* Tabs */
      .tabs-container {
        display: flex;
        gap: 8px;
        background: var(--bg-card);
        padding: 6px;
        border-radius: var(--radius-lg);
        width: fit-content;
      }

      .tab-btn {
        padding: 12px 24px;
        background: transparent;
        border: none;
        border-radius: var(--radius-md);
        color: var(--text-muted);
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .tab-btn:hover {
        color: var(--text-white);
      }

      .tab-btn.active {
        background: var(--primary);
        color: white;
        box-shadow: var(--shadow-sm);
      }

      /* Tab Panels */
      .tab-panel {
        display: none;
        flex: 1;
        flex-direction: column;
        gap: 20px;
      }

      .tab-panel.active {
        display: flex;
      }

      /* Input Panel */
      .input-section {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .input-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .input-title {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-white);
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .input-title svg {
        color: var(--primary);
      }

      .json-textarea {
        width: 100%;
        min-height: 450px;
        background: var(--bg-input);
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        padding: 20px;
        color: var(--text-white);
        font-family: "JetBrains Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.7;
        resize: vertical;
        transition: all 0.2s ease;
      }

      .json-textarea:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px var(--primary-light);
      }

      .json-textarea::placeholder {
        color: var(--text-dim);
      }

      /* Buttons */
      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: var(--radius-md);
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--primary),
          var(--primary-hover)
        );
        color: white;
        box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(99, 102, 241, 0.5);
      }

      .btn-secondary {
        background: var(--bg-card);
        color: var(--text-white);
        border: 1px solid var(--border);
      }

      .btn-secondary:hover {
        background: var(--bg-card-hover);
        border-color: var(--border-light);
      }

      .btn-success {
        background: linear-gradient(135deg, var(--secondary), #059669);
        color: white;
      }

      .btn-group {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      /* Output Panel */
      .output-section {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        overflow: hidden;
        flex: 1;
      }

      .output-header {
        padding: 20px 24px;
        background: rgba(232, 240, 250, 0.15);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .output-title {
        font-size: 1rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .output-content {
        padding: 24px;
        max-height: 500px;
        overflow-y: auto;
      }

      /* Parsed Content Sections */
      .parsed-section {
        margin-bottom: 24px;
        padding-bottom: 24px;
        border-bottom: 1px solid var(--border);
      }

      .parsed-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
      }

      .section-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }

      .section-icon {
        width: 28px;
        height: 28px;
        border-radius: var(--radius-sm);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.875rem;
      }

      .section-icon.taglines {
        background: var(--primary-light);
        color: var(--primary);
      }
      .section-icon.meta {
        background: var(--secondary-light);
        color: var(--secondary);
      }
      .section-icon.benefits {
        background: var(--accent-light);
        color: var(--accent);
      }
      .section-icon.when {
        background: rgba(236, 72, 153, 0.1);
        color: #ec4899;
      }
      .section-icon.how {
        background: rgba(14, 165, 233, 0.1);
        color: #0ea5e9;
      }
      .section-icon.summary {
        background: rgba(139, 92, 246, 0.1);
        color: #8b5cf6;
      }
      .section-icon.faq {
        background: var(--danger-light);
        color: var(--danger);
      }

      .section-title {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .section-content {
        color: var(--text-white);
        line-height: 1.8;
      }

      .section-content p {
        margin-bottom: 8px;
      }

      .section-content .subtitle {
        color: var(--text-dim);
        font-style: italic;
        margin-bottom: 12px;
      }

      .content-list {
        list-style: none;
        padding: 0;
      }

      .content-list li {
        padding: 10px 0;
        padding-left: 24px;
        position: relative;
        border-bottom: 1px solid rgba(51, 65, 85, 0.5);
      }

      .content-list li:last-child {
        border-bottom: none;
      }

      .content-list li::before {
        content: "‚Üí";
        position: absolute;
        left: 0;
        color: var(--primary);
      }

      /* Taglines */
      .taglines-container {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .tagline-chip {
        background: var(--primary-light);
        color: var(--primary);
        padding: 6px 14px;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 500;
      }

      /* FAQ */
      .faq-item {
        background: var(--bg-input);
        border-radius: var(--radius-md);
        padding: 16px;
        margin-bottom: 12px;
      }

      .faq-question {
        font-weight: 600;
        color: var(--primary);
        margin-bottom: 8px;
        display: flex;
        align-items: flex-start;
        gap: 10px;
      }

      .faq-question::before {
        content: "Q";
        background: var(--primary);
        color: white;
        width: 22px;
        height: 22px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        flex-shrink: 0;
      }

      .faq-answer {
        color: var(--text-muted);
        padding-left: 32px;
        line-height: 1.7;
      }

      /* Text Output */
      .text-output {
        background: var(--bg-input);
        border-radius: var(--radius-md);
        padding: 20px;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.8;
        color: var(--text-white);
        white-space: pre-wrap;
        min-height: 500px;
        max-height: calc(100vh - 400px);
        overflow-y: auto;
      }

      /* Empty State */
      .empty-state {
        text-align: center;
        padding: 60px 40px;
        color: var(--text-dim);
      }

      .empty-state svg {
        width: 80px;
        height: 80px;
        margin-bottom: 20px;
        opacity: 0.5;
      }

      .empty-state h3 {
        font-size: 1.25rem;
        color: var(--text-muted);
        margin-bottom: 8px;
      }

      .empty-state p {
        font-size: 0.9rem;
      }

      /* Error Message */
      .error-message {
        background: var(--danger-light);
        border: 1px solid rgba(239, 68, 68, 0.3);
        color: var(--danger);
        padding: 14px 18px;
        border-radius: var(--radius-md);
        font-size: 0.875rem;
        display: none;
        align-items: center;
        gap: 10px;
      }

      .error-message.show {
        display: flex;
      }

      /* Success Message */
      .success-message {
        background: var(--secondary-light);
        border: 1px solid rgba(16, 185, 129, 0.3);
        color: var(--secondary);
        padding: 14px 18px;
        border-radius: var(--radius-md);
        font-size: 0.875rem;
        display: none;
        align-items: center;
        gap: 10px;
      }

      .success-message.show {
        display: flex;
      }

      /* Scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }

      ::-webkit-scrollbar-track {
        background: var(--bg-dark);
      }

      ::-webkit-scrollbar-thumb {
        background: var(--border);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--border-light);
      }

      /* Responsive */
      @media (max-width: 1024px) {
        .main-container {
          flex-direction: column;
        }

        .sidebar {
          width: 100%;
          max-height: 200px;
          flex-direction: row;
          flex-wrap: nowrap;
          overflow-x: auto;
          padding: 16px;
        }

        .sidebar-header {
          display: none;
        }

        .id-list {
          flex-direction: row;
          gap: 8px;
        }

        .id-item {
          flex-shrink: 0;
        }

        .content-area {
          max-height: none;
        }
      }

      @media (max-width: 640px) {
        .header {
          padding: 16px 20px;
        }

        .content-area {
          padding: 20px;
        }

        .tabs-container {
          width: 100%;
        }

        .tab-btn {
          flex: 1;
          text-align: center;
          padding: 10px 12px;
          font-size: 0.8rem;
        }

        .btn-group {
          flex-direction: column;
        }

        .btn {
          width: 100%;
          justify-content: center;
        }
      }

      /* Animations */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .fade-in {
        animation: fadeIn 0.3s ease forwards;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .pulse {
        animation: pulse 2s infinite;
      }

      /* File Upload Button */
      .file-input-wrapper {
        position: relative;
        overflow: hidden;
        display: inline-block;
      }

      .file-input-wrapper input[type="file"] {
        position: absolute;
        left: 0;
        top: 0;
        opacity: 0;
        cursor: pointer;
        width: 100%;
        height: 100%;
      }

      .btn-upload {
        background: linear-gradient(135deg, var(--secondary), #059669);
        color: white;
        box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
      }

      .btn-upload:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(16, 185, 129, 0.5);
      }

      /* Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(15, 23, 42, 0.9);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        flex-direction: column;
        gap: 20px;
      }

      .loading-overlay.show {
        display: flex;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 4px solid var(--border);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        color: var(--text-white);
        font-size: 1rem;
        font-weight: 500;
      }

      .loading-progress {
        color: var(--text-muted);
        font-size: 0.875rem;
      }

      /* Edit Mode Styles */
      .text-output-editable {
        background: var(--bg-input);
        border-radius: var(--radius-md);
        padding: 20px;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.8;
        color: var(--text-white);
        white-space: pre-wrap;
        min-height: 500px;
        max-height: calc(100vh - 400px);
        overflow-y: auto;
        border: 2px solid transparent;
        transition: all 0.2s ease;
        width: 100%;
        resize: vertical;
      }

      .text-output-editable:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px var(--primary-light);
      }

      .text-output-editable.modified {
        border-color: var(--accent);
      }

      .btn-save {
        background: rgba(16, 185, 129, 0.1);
        color: var(--secondary);
        border: 1px solid var(--secondary);
        box-shadow: none;
      }

      .btn-save:hover {
        transform: translateY(-1px);
        background: rgba(16, 185, 129, 0.2);
      }

      .btn-save:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .btn-edit {
        background: var(--bg-card);
        color: var(--text-muted);
        border: 1px solid var(--border);
        box-shadow: none;
      }

      .btn-edit:hover {
        transform: translateY(-1px);
        background: var(--bg-card-hover);
        color: var(--primary);
        border-color: var(--primary);
      }

      .btn-edit.active {
        background: rgba(239, 68, 68, 0.1);
        color: var(--danger);
        border-color: var(--danger);
      }

      /* Icon-only buttons */
      .btn-icon {
        padding: 10px;
        min-width: 40px;
        height: 40px;
        justify-content: center;
      }

      .btn-icon svg {
        width: 18px;
        height: 18px;
      }

      .edit-status {
        font-size: 0.75rem;
        padding: 4px 10px;
        border-radius: 20px;
        font-weight: 500;
      }

      .edit-status.editing {
        background: var(--accent-light);
        color: var(--accent);
      }

      .edit-status.syncing {
        background: var(--primary-light);
        color: var(--primary);
        animation: pulse 0.5s ease-in-out infinite alternate;
      }

      @keyframes pulse {
        from {
          opacity: 0.7;
        }
        to {
          opacity: 1;
        }
      }

      .edit-status.saved {
        background: var(--secondary-light);
        color: var(--secondary);
      }

      .header-buttons {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .btn-download {
        background: var(--bg-card);
        color: var(--text-muted);
        border: 1px solid var(--border);
        box-shadow: none;
      }

      .btn-download:hover {
        transform: translateY(-1px);
        background: rgba(59, 130, 246, 0.1);
        color: #3b82f6;
        border-color: #3b82f6;
      }

      .btn-download:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .btn-select {
        background: var(--bg-card);
        color: var(--text-muted);
        border: 1px solid var(--border);
        box-shadow: none;
      }

      .btn-select:hover {
        transform: translateY(-1px);
        background: rgba(16, 185, 129, 0.1);
        color: var(--secondary);
        border-color: var(--secondary);
      }

      .btn-select.selected {
        background: rgba(16, 185, 129, 0.15);
        color: var(--secondary);
        border-color: var(--secondary);
      }

      .btn-delete {
        background: var(--bg-card);
        color: var(--text-muted);
        border: 1px solid var(--border);
        box-shadow: none;
      }

      .btn-delete:hover {
        transform: translateY(-1px);
        background: rgba(239, 68, 68, 0.1);
        color: var(--danger);
        border-color: var(--danger);
      }

      .id-item.selected {
        background: var(--secondary-light);
        border-color: var(--secondary);
      }

      .id-item.selected .id-number {
        background: var(--secondary);
        color: white;
      }

      .id-item.deleted {
        opacity: 0.4;
        text-decoration: line-through;
        pointer-events: none;
      }

      .selected-badge {
        background: var(--secondary);
        color: white;
        font-size: 0.65rem;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 8px;
      }

      .deleted-badge {
        background: var(--danger);
        color: white;
        font-size: 0.65rem;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 8px;
      }

      .column-info {
        font-size: 0.7rem;
        color: var(--text-dim);
        margin-top: 4px;
      }

      /* Animated Copy Toast */
      .copy-toast {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.5);
        background: linear-gradient(135deg, var(--secondary), #059669);
        color: white;
        padding: 20px 40px;
        border-radius: var(--radius-lg);
        font-size: 1.1rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 12px;
        box-shadow: 0 20px 60px rgba(16, 185, 129, 0.5);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        z-index: 10000;
      }

      .copy-toast.show {
        opacity: 1;
        visibility: visible;
        transform: translate(-50%, -50%) scale(1);
      }

      .copy-toast svg {
        width: 28px;
        height: 28px;
        animation: checkmark 0.4s ease-out 0.1s forwards;
      }

      @keyframes checkmark {
        0% {
          stroke-dashoffset: 50;
        }
        100% {
          stroke-dashoffset: 0;
        }
      }

      .copy-toast svg path {
        stroke-dasharray: 50;
        stroke-dashoffset: 50;
      }

      .copy-toast::before {
        content: "";
        position: absolute;
        top: -10px;
        left: -10px;
        right: -10px;
        bottom: -10px;
        background: linear-gradient(135deg, var(--secondary), #059669);
        border-radius: var(--radius-xl);
        z-index: -1;
        opacity: 0;
        animation: pulse-ring 0.6s ease-out;
      }

      @keyframes pulse-ring {
        0% {
          opacity: 0.8;
          transform: scale(1);
        }
        100% {
          opacity: 0;
          transform: scale(1.3);
        }
      }
    </style>
  </head>

  <body>
    <!-- Header -->
    <header class="header">
      <div class="header-content">
        <div class="logo">
          <div class="logo-icon">üìÑ</div>
          <div class="logo-text">
            <h1>JSON Parser</h1>
            <span>Convert ‚Ä¢ Parse ‚Ä¢ Organize</span>
          </div>
        </div>
        <div class="header-actions">
          <button
            class="theme-toggle"
            onclick="toggleTheme()"
            title="Toggle theme"
          >
            <svg
              class="moon-icon"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
              />
            </svg>
            <svg
              class="sun-icon"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
              />
            </svg>
          </button>
          <div class="file-name-display" id="fileNameDisplay">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
              />
            </svg>
            <span class="file-name-text" id="fileNameText"></span>
          </div>
          <div class="file-input-wrapper">
            <button class="btn btn-upload">
              <svg
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                />
              </svg>
              Load Excel
            </button>
            <input
              type="file"
              id="excelFileInput"
              accept=".xlsx,.xls"
              onchange="handleExcelUpload(event)"
            />
          </div>
          <button
            class="btn btn-download"
            id="downloadExcelBtn"
            onclick="downloadExcel()"
            style="display: none"
          >
            <svg
              width="16"
              height="16"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
              />
            </svg>
            Download
          </button>
          <button class="btn btn-secondary" onclick="clearAll()">
            <svg
              width="16"
              height="16"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
              />
            </svg>
            Clear All
          </button>
        </div>
      </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
      <!-- Sidebar - ID List -->
      <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <span class="sidebar-title">Data IDs</span>
          <span class="id-count" id="idCount">0</span>
        </div>
        <div class="id-list" id="idList">
          <div class="empty-state" style="padding: 30px 10px">
            <p>No data loaded yet</p>
          </div>
        </div>
      </aside>

      <!-- Content Area -->
      <main class="content-area">
        <!-- Tabs -->
        <div class="tabs-container">
          <button class="tab-btn active" onclick="switchTab('input')">
            üìù JSON Input
          </button>
          <button class="tab-btn" onclick="switchTab('parsed')">
            ‚ú® Parsed View
          </button>
          <button class="tab-btn" onclick="switchTab('text')">
            üìã Plain Text
          </button>
        </div>

        <!-- Input Tab -->
        <div class="tab-panel active" id="input-panel">
          <div class="input-section">
            <div class="input-header">
              <div class="input-title">
                <svg
                  width="20"
                  height="20"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"
                  />
                </svg>
                Paste Your JSON Here
              </div>
              <div class="header-buttons">
                <button
                  class="btn btn-secondary btn-icon"
                  onclick="copyJSON()"
                  title="Copy JSON"
                >
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                    />
                  </svg>
                </button>
              </div>
            </div>
            <textarea
              class="json-textarea"
              id="jsonInput"
              placeholder='{
  "taglines": ["Tag 1", "Tag 2"],
  "meta_title": "Your Title",
  "meta_description": "Your description",
  "benefits": {
    "title": "Benefits Title",
    "subtitle": "Benefits subtitle",
    "content": ["Benefit 1", "Benefit 2"]
  },
  "when_to_recite": {
    "title": "When Title",
    "subtitle": "When subtitle",
    "content": ["When 1", "When 2"]
  },
  "how_to_perform": {
    "title": "How Title",
    "subtitle": "How subtitle",
    "content": ["Step 1", "Step 2"]
  },
  "summary": ["Summary paragraph 1", "Summary paragraph 2"],
  "faqs": [
    {"question": "Question 1?", "answer": "Answer 1"},
    {"question": "Question 2?", "answer": "Answer 2"}
  ]
}'
            ></textarea>

            <div id="errorMsg" class="error-message">
              <svg
                width="20"
                height="20"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
              <span id="errorText"></span>
            </div>

            <div id="successMsg" class="success-message">
              <svg
                width="20"
                height="20"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
              <span id="successText"></span>
            </div>

            <div class="btn-group">
              <button class="btn btn-primary" onclick="parseJSON()">
                <svg
                  width="18"
                  height="18"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M13 10V3L4 14h7v7l9-11h-7z"
                  />
                </svg>
                Parse JSON
              </button>
              <button class="btn btn-secondary" onclick="addToList()">
                <svg
                  width="18"
                  height="18"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M12 6v6m0 0v6m0-6h6m-6 0H6"
                  />
                </svg>
                Add to List
              </button>
              <button class="btn btn-secondary" onclick="loadSampleData()">
                <svg
                  width="18"
                  height="18"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                  />
                </svg>
                Load Sample
              </button>
            </div>
          </div>
        </div>

        <!-- Parsed View Tab -->
        <div class="tab-panel" id="parsed-panel">
          <div class="output-section">
            <div class="output-header">
              <div class="output-title">
                <svg
                  width="20"
                  height="20"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                  />
                </svg>
                Parsed Content
              </div>
              <button class="btn btn-secondary" onclick="copyParsed()">
                <svg
                  width="16"
                  height="16"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                  />
                </svg>
                Copy
              </button>
            </div>
            <div class="output-content" id="parsedOutput">
              <div class="empty-state">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="1.5"
                    d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                  />
                </svg>
                <h3>No Content Yet</h3>
                <p>Paste JSON in the input tab and click "Parse JSON"</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Plain Text Tab -->
        <div class="tab-panel" id="text-panel">
          <div class="output-section">
            <div class="output-header">
              <div class="output-title">
                <svg
                  width="20"
                  height="20"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M4 6h16M4 12h16M4 18h7"
                  />
                </svg>
                Plain Text Output
                <span
                  class="edit-status"
                  id="editStatus"
                  style="display: none"
                ></span>
              </div>
              <div class="header-buttons">
                <button
                  class="btn btn-select btn-icon"
                  id="selectToggleBtn"
                  onclick="toggleSelectStatus()"
                  title="Select"
                >
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M5 13l4 4L19 7"
                    />
                  </svg>
                </button>
                <button
                  class="btn btn-delete btn-icon"
                  id="deleteRowBtn"
                  onclick="deleteCurrentRow()"
                  title="Delete"
                >
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                    />
                  </svg>
                </button>
                <button
                  class="btn btn-edit btn-icon"
                  id="editToggleBtn"
                  onclick="toggleEditMode()"
                  title="Edit"
                >
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                    />
                  </svg>
                </button>
                <button
                  class="btn btn-save btn-icon"
                  id="saveChangesBtn"
                  onclick="saveTextChanges()"
                  style="display: none"
                  title="Save"
                >
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"
                    />
                  </svg>
                </button>
                <button
                  class="btn btn-secondary btn-icon"
                  onclick="copyText()"
                  title="Copy"
                >
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                    />
                  </svg>
                </button>
              </div>
            </div>
            <div class="output-content">
              <div class="text-output" id="textOutput">
                Parse JSON to see plain text output here...
              </div>
              <textarea
                class="text-output-editable"
                id="textOutputEditable"
                style="display: none"
                oninput="onTextEdit()"
              ></textarea>
            </div>
          </div>
        </div>
      </main>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading Excel File...</div>
      <div class="loading-progress" id="loadingProgress">Please wait</div>
    </div>

    <!-- Copy Toast -->
    <div class="copy-toast" id="copyToast">
      <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="3"
          d="M5 13l4 4L19 7"
        />
      </svg>
      <span id="copyToastText">Copied!</span>
    </div>

    <script>
      // Theme functions
      function toggleTheme() {
        const html = document.documentElement;
        const currentTheme = html.getAttribute("data-theme");
        const newTheme = currentTheme === "light" ? "dark" : "light";
        html.setAttribute("data-theme", newTheme);
        localStorage.setItem("theme", newTheme);
      }

      // Load saved theme on page load
      (function () {
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme) {
          document.documentElement.setAttribute("data-theme", savedTheme);
        } else {
          // Default to dark theme
          document.documentElement.setAttribute("data-theme", "dark");
        }
      })();

      // Global data store
      let dataStore = [];
      let currentData = null;
      let activeId = null;

      // Original Excel data for smart update
      let originalWorkbook = null;
      let originalSheetName = null;
      let columnHeaders = { id: "ID", content: "input" }; // Dynamic headers
      let deletedIds = new Set(); // Track deleted rows
      let selectedIds = new Set(); // Track selected rows
      let currentFileName = null; // Track current loaded file name
      let showFileName = false; // Toggle for showing file name in output

      // IndexedDB setup
      const DB_NAME = "JsonParserDB";
      const DB_VERSION = 1;
      const STORE_NAME = "jsonData";
      let db = null;

      // Open IndexedDB
      function openDatabase() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);

          request.onerror = () => {
            console.error("Failed to open IndexedDB:", request.error);
            reject(request.error);
          };

          request.onsuccess = () => {
            db = request.result;
            console.log("IndexedDB opened successfully");
            resolve(db);
          };

          request.onupgradeneeded = (event) => {
            const database = event.target.result;
            if (!database.objectStoreNames.contains(STORE_NAME)) {
              database.createObjectStore(STORE_NAME, { keyPath: "key" });
              console.log("Object store created");
            }
          };
        });
      }

      // Save data to IndexedDB
      async function saveToStorage() {
        try {
          if (!db) await openDatabase();

          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);

          // Save dataStore
          store.put({ key: "dataStore", value: dataStore });
          // Save activeId
          store.put({ key: "activeId", value: activeId });
          // Save selected and deleted IDs
          store.put({ key: "selectedIds", value: Array.from(selectedIds) });
          store.put({ key: "deletedIds", value: Array.from(deletedIds) });
          store.put({ key: "columnHeaders", value: columnHeaders });
          // Save file name
          store.put({ key: "currentFileName", value: currentFileName });

          transaction.oncomplete = () => {
            console.log("Data saved to IndexedDB:", dataStore.length, "items");
          };

          transaction.onerror = () => {
            console.error("Failed to save to IndexedDB:", transaction.error);
          };
        } catch (e) {
          console.error("Failed to save to IndexedDB:", e);
        }
      }

      // Load data from IndexedDB
      function loadFromStorage() {
        return new Promise(async (resolve, reject) => {
          try {
            if (!db) await openDatabase();

            const transaction = db.transaction([STORE_NAME], "readonly");
            const store = transaction.objectStore(STORE_NAME);

            const dataRequest = store.get("dataStore");
            const activeIdRequest = store.get("activeId");
            const selectedIdsRequest = store.get("selectedIds");
            const deletedIdsRequest = store.get("deletedIds");
            const columnHeadersRequest = store.get("columnHeaders");
            const fileNameRequest = store.get("currentFileName");

            transaction.oncomplete = () => {
              const savedData = dataRequest.result;
              const savedActiveId = activeIdRequest.result;
              const savedSelectedIds = selectedIdsRequest.result;
              const savedDeletedIds = deletedIdsRequest.result;
              const savedColumnHeaders = columnHeadersRequest.result;
              const savedFileName = fileNameRequest.result;

              console.log(
                "Loading from IndexedDB, found data:",
                savedData ? "yes" : "no"
              );

              if (savedData && savedData.value) {
                dataStore = savedData.value;
                console.log("Parsed dataStore:", dataStore.length, "items");
                activeId = savedActiveId ? savedActiveId.value : null;

                // Restore selected and deleted IDs
                if (savedSelectedIds && savedSelectedIds.value) {
                  selectedIds = new Set(savedSelectedIds.value);
                }
                if (savedDeletedIds && savedDeletedIds.value) {
                  deletedIds = new Set(savedDeletedIds.value);
                }
                if (savedColumnHeaders && savedColumnHeaders.value) {
                  columnHeaders = savedColumnHeaders.value;
                }
                // Restore file name
                if (savedFileName && savedFileName.value) {
                  currentFileName = savedFileName.value;
                  document.getElementById("fileNameText").textContent =
                    currentFileName;
                  document
                    .getElementById("fileNameDisplay")
                    .classList.add("show");
                }

                renderIdList();

                // Show download button if data exists
                if (dataStore.length > 0) {
                  document.getElementById("downloadExcelBtn").style.display =
                    "inline-flex";
                }

                // If there was an active item, restore it
                if (
                  activeId &&
                  dataStore.length > 0 &&
                  !deletedIds.has(activeId)
                ) {
                  selectId(activeId);
                }
              }
              resolve();
            };

            transaction.onerror = () => {
              console.error(
                "Failed to load from IndexedDB:",
                transaction.error
              );
              reject(transaction.error);
            };
          } catch (e) {
            console.error("Failed to load from IndexedDB:", e);
            dataStore = [];
            activeId = null;
            reject(e);
          }
        });
      }

      // Clear IndexedDB
      function clearStorage() {
        if (!db) return;

        const transaction = db.transaction([STORE_NAME], "readwrite");
        const store = transaction.objectStore(STORE_NAME);
        store.clear();

        transaction.oncomplete = () => {
          console.log("IndexedDB cleared");
        };
      }

      // Sample data based on user's JSON structure
      const sampleData = {
        taglines: [
          "Rizq Dua",
          "Masnoon Dua",
          "After Salah",
          "Wealth Dua",
          "Sahih Bukhari",
        ],
        meta_title: "Dua for Rizq and Help After Prayer for Wealth and Success",
        meta_description:
          "Read this dua after prayer for rizq and help. Learn the correct way to ask Allah for wealth and barakah with this masnoon dua for success in your life.",
        benefits: {
          title: "Benefits of Dua After Prayer for Rizq",
          subtitle:
            "Reciting this beautiful dua brings peace to the heart because it reminds you that only Allah is the one who gives provision and no one can stop His blessings from reaching you.",
          content: [
            "Saying Allahumma la mania lima ataita helps you trust that your rizq is written only by Allah.",
            "This dua after prayer removes fear of people because you know they cannot stop Allah's help.",
            "It keeps the heart humble by reminding us that our hard work only succeeds with Allah's permission.",
            "Reciting this dua for rizq protects a muslim from being jealous of others who have wealth.",
            "This masnoon dua strengthens your connection with Allah after every fard prayer you perform.",
          ],
        },
        when_to_recite: {
          title: "When to Recite Dua After Prayer for Help",
          subtitle:
            "You should make it a habit to say these words at specific times to follow the sunnah and to remind yourself that all success and wealth come directly from the command of Allah.",
          content: [
            "The best time to recite this dua for rizq is immediately after saying tasleem in fard prayer.",
            "You can say this dua for wealth whenever you feel worried about your job or money matters.",
            "It is good to recite this dua for help from Allah in the morning to start your day with trust.",
            "Recite this dua after namaz especially when you finish your daily prayers at the mosque or home.",
            "Use this dua for rizq and success when you are making your daily dhikr and remembering Allah.",
          ],
        },
        how_to_perform: {
          title: "How to perform Dua After Prayer for Rizq",
          subtitle:
            "Doing this act of worship is very simple and brings great rewards if you focus on the meaning while affirming that no one can stop what Allah decides to give you in this life.",
          content: [
            "Sit calmly after your fard prayer and finish the tasleem before you start this dua for rizq.",
            "You do not need to raise hands but say the words La ilaha illallahu wahdahu with full focus.",
            "Understand that when you say Allahumma la mania you are admitting only Allah has power.",
            "Recite this dua after prayer individually with a low voice so you can hear yourself speak.",
            "Make sure you pronounce the arabic words clearly or read the translation if you are learning.",
          ],
        },
        summary: [
          "The Dua After Prayer for Rizq and Help is a very strong statement that comes from authentic hadith. It teaches us that Allah is the Owner of everything. When a muslim recites this, they admit that if Allah wants to give wealth, nobody can stop it, and if He holds it back, nobody can force Him to give it.",
          "Using this dua for rizq and wealth daily changes how you look at life. It makes you rely less on people and more on your Creator. By reciting this dua after namaz regularly, you find peace knowing that your success is in safe hands. It is a simple way to ask Allah for help and keep your faith strong.",
        ],
        faqs: [
          {
            question: "Does this dua for rizq guarantee wealth?",
            answer:
              "This dua for rizq builds trust in Allah. It brings barakah in what you have and opens doors for wealth if it is good for you, but exact results depend on Allah.",
          },
          {
            question: "Can I read this dua for help without wudu?",
            answer:
              "Yes, you can read this dua for help from Allah without wudu as it is a form of dhikr. However, it is usually recited right after fard prayer when you have wudu.",
          },
          {
            question: "Is this a powerful dua for rizq and success?",
            answer:
              "Yes, this is a very powerful dua for rizq because it was recited by the Prophet. It affirms that all success and provision come only from Allah's command.",
          },
          {
            question: "How many times should I read dua for rizk?",
            answer:
              "There is no fixed number for this dua for rizk. The sunnah is to recite it once after every fard prayer. You can also repeat it more times as general dhikr.",
          },
          {
            question: "Where is this dua after prayer found?",
            answer:
              "This dua after prayer is found in Sahih Bukhari and Sahih Muslim. It is an authentic masnoon dua that the Prophet used to say after finishing his prayers.",
          },
        ],
      };

      // Switch between tabs
      function switchTab(tabName) {
        // Remove active class from all tabs and panels
        document
          .querySelectorAll(".tab-btn")
          .forEach((btn) => btn.classList.remove("active"));
        document
          .querySelectorAll(".tab-panel")
          .forEach((panel) => panel.classList.remove("active"));

        // Add active class to selected tab and panel
        event.target.classList.add("active");
        document.getElementById(`${tabName}-panel`).classList.add("active");
      }

      // Parse JSON from input
      function parseJSON() {
        const input = document.getElementById("jsonInput").value.trim();
        const errorMsg = document.getElementById("errorMsg");
        const errorText = document.getElementById("errorText");
        const successMsg = document.getElementById("successMsg");
        const successText = document.getElementById("successText");

        errorMsg.classList.remove("show");
        successMsg.classList.remove("show");

        if (!input) {
          errorText.textContent = "Please enter JSON data to parse.";
          errorMsg.classList.add("show");
          return;
        }

        try {
          currentData = JSON.parse(input);
          renderParsedContent(currentData);
          renderPlainText(currentData);

          successText.textContent =
            'JSON parsed successfully! Switch to "Parsed View" or "Plain Text" to see results.';
          successMsg.classList.add("show");

          // Auto-switch to parsed view
          setTimeout(() => {
            document.querySelectorAll(".tab-btn")[1].click();
          }, 500);
        } catch (e) {
          errorText.textContent = "Invalid JSON: " + e.message;
          errorMsg.classList.add("show");
        }
      }

      // Add current JSON to ID list
      function addToList() {
        const input = document.getElementById("jsonInput").value.trim();
        const errorMsg = document.getElementById("errorMsg");
        const errorText = document.getElementById("errorText");
        const successMsg = document.getElementById("successMsg");
        const successText = document.getElementById("successText");

        errorMsg.classList.remove("show");
        successMsg.classList.remove("show");

        if (!input) {
          errorText.textContent = "Please enter JSON data first.";
          errorMsg.classList.add("show");
          return;
        }

        try {
          const data = JSON.parse(input);
          const id = dataStore.length + 1;
          const title = data.meta_title || data.title || `Data #${id}`;

          dataStore.push({
            id: id,
            title: title.substring(0, 40) + (title.length > 40 ? "..." : ""),
            data: data,
          });

          renderIdList();
          saveToStorage();

          successText.textContent = `Added as ID #${id} to the list!`;
          successMsg.classList.add("show");

          // Clear input after adding
          document.getElementById("jsonInput").value = "";
        } catch (e) {
          errorText.textContent = "Invalid JSON: " + e.message;
          errorMsg.classList.add("show");
        }
      }

      // Render ID list in sidebar
      function renderIdList() {
        const idList = document.getElementById("idList");
        const idCount = document.getElementById("idCount");

        // Count non-deleted items
        const activeCount = dataStore.filter(
          (d) => !deletedIds.has(d.id)
        ).length;
        idCount.textContent = activeCount;

        if (dataStore.length === 0) {
          idList.innerHTML = `
                    <div class="empty-state" style="padding: 30px 10px;">
                        <p>No data loaded yet</p>
                    </div>
                `;
          return;
        }

        idList.innerHTML = dataStore
          .map((item) => {
            const isDeleted = deletedIds.has(item.id);
            const isSelected = selectedIds.has(item.id);
            const isActive = activeId === item.id;

            let classes = "id-item";
            if (isActive) classes += " active";
            if (isSelected) classes += " selected";
            if (isDeleted) classes += " deleted";

            let badges = "";
            if (isSelected) badges += '<span class="selected-badge">‚úì</span>';
            if (isDeleted)
              badges += '<span class="deleted-badge">Deleted</span>';

            return `
                <div class="${classes}" onclick="${
              isDeleted ? "" : "selectId(" + item.id + ")"
            }">
                    <div class="id-number">${item.id}</div>
                    <div class="id-label">${item.title}${badges}</div>
                </div>
            `;
          })
          .join("");
      }

      // Select an ID from the list
      function selectId(id) {
        // Skip if deleted
        if (deletedIds.has(id)) return;

        // Reset edit mode if active
        if (isEditMode) {
          isEditMode = false;
          document.getElementById("textOutput").style.display = "block";
          document.getElementById("textOutputEditable").style.display = "none";
          document.getElementById("editToggleBtn").classList.remove("active");
          document.getElementById("saveChangesBtn").style.display = "none";
          document.getElementById("editStatus").style.display = "none";
          hasUnsavedChanges = false;
        }

        activeId = id;

        // Update select button state
        const selectBtn = document.getElementById("selectToggleBtn");
        if (selectedIds.has(id)) {
          selectBtn.classList.add("selected");
        } else {
          selectBtn.classList.remove("selected");
        }

        // Find item with loose equality to handle string/number differences
        const item = dataStore.find((d) => d.id == id);

        console.log("selectId called with:", id);
        console.log("Found item:", item);

        if (item) {
          currentData = item.data;

          console.log("Item data:", item.data);
          console.log("Item data type:", typeof item.data);
          console.log(
            "Item data keys:",
            item.data ? Object.keys(item.data) : "null"
          );

          document.getElementById("jsonInput").value = JSON.stringify(
            item.data,
            null,
            2
          );
          renderParsedContent(item.data);
          renderPlainText(item.data);
          renderIdList();
          saveToStorage();

          // Switch to Plain Text tab (index 2) for Excel loaded data
          document.querySelectorAll(".tab-btn")[2].click();
        } else {
          console.warn("No item found for ID:", id);
        }
      }

      // Render parsed content with styled sections
      function renderParsedContent(data) {
        const output = document.getElementById("parsedOutput");
        let html = "";

        // Taglines
        if (data.taglines && Array.isArray(data.taglines)) {
          html += `
                    <div class="parsed-section fade-in">
                        <div class="section-header">
                            <div class="section-icon taglines">üè∑Ô∏è</div>
                            <span class="section-title">Taglines</span>
                        </div>
                        <div class="section-content">
                            <div class="taglines-container">
                                ${data.taglines
                                  .map(
                                    (tag) =>
                                      `<span class="tagline-chip">${escapeHtml(
                                        tag
                                      )}</span>`
                                  )
                                  .join("")}
                            </div>
                        </div>
                    </div>
                `;
        }

        // Meta Title & Description
        if (data.meta_title || data.meta_description) {
          html += `
                    <div class="parsed-section fade-in">
                        <div class="section-header">
                            <div class="section-icon meta">üìå</div>
                            <span class="section-title">Meta Information</span>
                        </div>
                        <div class="section-content">
                            ${
                              data.meta_title
                                ? `<p><strong>Title:</strong> ${escapeHtml(
                                    data.meta_title
                                  )}</p>`
                                : ""
                            }
                            ${
                              data.meta_description
                                ? `<p><strong>Description:</strong> ${escapeHtml(
                                    data.meta_description
                                  )}</p>`
                                : ""
                            }
                        </div>
                    </div>
                `;
        }

        // Benefits
        if (data.benefits) {
          html += renderContentSection(
            data.benefits,
            "Benefits",
            "benefits",
            "‚≠ê"
          );
        }

        // When to Recite
        if (data.when_to_recite) {
          html += renderContentSection(
            data.when_to_recite,
            "When to Recite",
            "when",
            "‚è∞"
          );
        }

        // How to Perform
        if (data.how_to_perform) {
          html += renderContentSection(
            data.how_to_perform,
            "How to Perform",
            "how",
            "üìù"
          );
        }

        // Summary
        if (data.summary && Array.isArray(data.summary)) {
          html += `
                    <div class="parsed-section fade-in">
                        <div class="section-header">
                            <div class="section-icon summary">üìñ</div>
                            <span class="section-title">Summary</span>
                        </div>
                        <div class="section-content">
                            ${data.summary
                              .map((p) => `<p>${escapeHtml(p)}</p>`)
                              .join("")}
                        </div>
                    </div>
                `;
        }

        // FAQs
        if (data.faqs && Array.isArray(data.faqs)) {
          html += `
                    <div class="parsed-section fade-in">
                        <div class="section-header">
                            <div class="section-icon faq">‚ùì</div>
                            <span class="section-title">Frequently Asked Questions</span>
                        </div>
                        <div class="section-content">
                            ${data.faqs
                              .map(
                                (faq) => `
                                <div class="faq-item">
                                    <div class="faq-question">${escapeHtml(
                                      faq.question
                                    )}</div>
                                    <div class="faq-answer">${escapeHtml(
                                      faq.answer
                                    )}</div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    </div>
                `;
        }

        if (!html) {
          // Debug: show what keys we have
          console.log(
            "Data has no recognized sections. Keys available:",
            Object.keys(data)
          );
          console.log("Full data:", data);

          // Fallback: show raw data in a formatted way
          html = `
                    <div class="parsed-section fade-in">
                        <div class="section-header">
                            <div class="section-icon meta">üìÑ</div>
                            <span class="section-title">Raw JSON Data</span>
                        </div>
                        <div class="section-content">
                            <p><strong>Available keys:</strong> ${Object.keys(
                              data
                            ).join(", ")}</p>
                            <pre style="background: var(--bg-input); padding: 16px; border-radius: 8px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; line-height: 1.6; max-height: 400px; overflow-y: auto;">${escapeHtml(
                              JSON.stringify(data, null, 2)
                            )}</pre>
                        </div>
                    </div>
                `;
        }

        output.innerHTML = html;
      }

      // Helper to render a single section item
      function renderSingleSection(section, label, iconClass, emoji) {
        return `
                <div class="parsed-section fade-in">
                    <div class="section-header">
                        <div class="section-icon ${iconClass}">${emoji}</div>
                        <span class="section-title">${
                          section.title || label
                        }</span>
                    </div>
                    <div class="section-content">
                        ${
                          section.subtitle
                            ? `<p class="subtitle">${escapeHtml(
                                section.subtitle
                              )}</p>`
                            : ""
                        }
                        ${
                          section.content && Array.isArray(section.content)
                            ? `
                            <ul class="content-list">
                                ${section.content
                                  .map((item) => `<li>${escapeHtml(item)}</li>`)
                                  .join("")}
                            </ul>
                        `
                            : ""
                        }
                    </div>
                </div>
            `;
      }

      // Helper to render content sections (benefits, when, how) - handles both object and array formats
      function renderContentSection(section, label, iconClass, emoji) {
        // Handle array format: [{ title, subtitle, content }]
        if (Array.isArray(section)) {
          return section
            .map((item) => renderSingleSection(item, label, iconClass, emoji))
            .join("");
        }
        // Handle single object format: { title, subtitle, content }
        return renderSingleSection(section, label, iconClass, emoji);
      }

      // Helper to strip HTML tags from text
      function stripHtmlTags(text) {
        if (!text) return "";
        if (typeof text !== "string") return String(text);
        // Remove HTML tags
        let clean = text.replace(/<[^>]+>/g, "");
        // Replace multiple spaces/newlines with single space
        clean = clean.replace(/\s+/g, " ");
        return clean.trim();
      }

      // Helper to convert any value to plain text recursively
      function convertValueToText(value, depth = 0) {
        const indent = "  ".repeat(depth);
        let result = [];

        if (value === null || value === undefined) {
          return [];
        }

        if (typeof value === "string") {
          const cleaned = stripHtmlTags(value);
          if (cleaned) result.push(cleaned);
        } else if (typeof value === "number" || typeof value === "boolean") {
          result.push(String(value));
        } else if (Array.isArray(value)) {
          value.forEach((item, index) => {
            if (typeof item === "object" && item !== null) {
              // For objects in array, process recursively
              const itemText = convertValueToText(item, depth);
              result = result.concat(itemText);
            } else if (typeof item === "string") {
              const cleaned = stripHtmlTags(item);
              if (cleaned) result.push(cleaned);
            } else if (item !== null && item !== undefined) {
              result.push(String(item));
            }
          });
        } else if (typeof value === "object") {
          // For nested objects, process each property
          Object.entries(value).forEach(([key, val]) => {
            const nested = convertValueToText(val, depth);
            result = result.concat(nested);
          });
        }

        return result;
      }

      // Helper to add section text (handles both object and array formats)
      function addSectionText(text, section, label) {
        if (!section) return;

        // Handle array format: [{ title, subtitle, content }]
        if (Array.isArray(section)) {
          section.forEach((item, idx) => {
            if (idx === 0) text.push(`${label}:`);
            if (item.title) text.push(item.title);
            if (item.subtitle) text.push(item.subtitle);
            if (item.content && Array.isArray(item.content)) {
              item.content.forEach((c, i) => {
                text.push(`${i + 1}. ${c}`);
              });
            }
            text.push("");
          });
        }
        // Handle single object format: { title, subtitle, content }
        else if (typeof section === "object") {
          text.push(`${label}:`);
          if (section.title) text.push(section.title);
          if (section.subtitle) text.push(section.subtitle);
          if (section.content && Array.isArray(section.content)) {
            section.content.forEach((item, i) => {
              text.push(`${i + 1}. ${item}`);
            });
          }
          text.push("");
        }
      }

      // Render plain text output - GENERIC VERSION for ANY JSON structure
      function renderPlainText(data) {
        const output = document.getElementById("textOutput");
        let text = [];

        if (!data || typeof data !== "object") {
          output.textContent = "Invalid data";
          return;
        }

        // Try to detect if this is a structured format we know
        const hasKnownStructure =
          data.taglines ||
          data.meta_title ||
          data.benefits ||
          data.when_to_recite ||
          data.how_to_perform ||
          data.summary ||
          data.faqs;

        if (hasKnownStructure) {
          // Use the old structured approach for known formats
          // Taglines
          if (data.taglines && Array.isArray(data.taglines)) {
            text.push("TAGLINES:");
            text.push(data.taglines.join(", "));
            text.push("");
          }

          // Meta
          if (data.meta_title) {
            text.push("META TITLE:");
            text.push(data.meta_title);
            text.push("");
          }

          if (data.meta_description) {
            text.push("META DESCRIPTION:");
            text.push(data.meta_description);
            text.push("");
          }

          // Benefits (handles both object and array format)
          addSectionText(text, data.benefits, "BENEFITS");

          // When to Recite (handles both object and array format)
          addSectionText(text, data.when_to_recite, "WHEN TO RECITE");

          // How to Perform (handles both object and array format)
          addSectionText(text, data.how_to_perform, "HOW TO PERFORM");

          // Summary
          if (data.summary && Array.isArray(data.summary)) {
            text.push("SUMMARY:");
            data.summary.forEach((p) => text.push(p));
            text.push("");
          }

          // FAQs
          if (data.faqs && Array.isArray(data.faqs)) {
            text.push("FREQUENTLY ASKED QUESTIONS:");
            data.faqs.forEach((faq, i) => {
              text.push(`Q${i + 1}: ${faq.question}`);
              text.push(`A${i + 1}: ${faq.answer}`);
              text.push("");
            });
          }
        } else {
          // Generic approach for ANY JSON structure
          console.log("Using generic JSON to text conversion");

          // Process all key-value pairs recursively
          Object.entries(data).forEach(([key, value]) => {
            // Add section header with formatted key name
            const formattedKey = key
              .replace(/_/g, " ")
              .replace(/([A-Z])/g, " $1")
              .trim()
              .toUpperCase();

            // Convert the value to text
            const valueText = convertValueToText(value, 0);

            if (valueText.length > 0) {
              text.push(`${formattedKey}:`);
              text = text.concat(valueText);
              text.push("");
            }
          });
        }

        // If still no text extracted, show a message
        if (text.length === 0) {
          text.push("No text content could be extracted from this JSON.");
          text.push("");
          text.push("Raw JSON:");
          text.push(JSON.stringify(data, null, 2));
        }

        output.textContent = text.join("\n");
      }

      // Copy functions
      function copyParsed() {
        const output = document.getElementById("parsedOutput");
        const text = output.innerText;
        copyToClipboard(text, "Parsed content copied!");
      }

      function copyText() {
        // Copy from editable if in edit mode, otherwise from display
        const text = isEditMode
          ? document.getElementById("textOutputEditable").value
          : document.getElementById("textOutput").textContent;
        copyToClipboard(text, "Plain text copied!");
      }

      function copyJSON() {
        const text = document.getElementById("jsonInput").value;
        if (!text.trim()) {
          showToast("No JSON to copy!");
          return;
        }
        copyToClipboard(text, "JSON copied!");
      }

      function copyToClipboard(text, message) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast(message);
          })
          .catch(() => {
            // Fallback
            const textarea = document.createElement("textarea");
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            document.body.removeChild(textarea);
            showToast(message);
          });
      }

      function showToast(message) {
        // Check if it's a copy message
        if (message.toLowerCase().includes("copied")) {
          showCopyToast(message);
        } else {
          // Use the regular success message for other notifications
          const successMsg = document.getElementById("successMsg");
          const successText = document.getElementById("successText");
          successText.textContent = message;
          successMsg.classList.add("show");
          setTimeout(() => successMsg.classList.remove("show"), 2000);
        }
      }

      function showCopyToast(message) {
        const toast = document.getElementById("copyToast");
        const toastText = document.getElementById("copyToastText");

        if (!toast || !toastText) {
          console.error("Toast elements not found");
          return;
        }

        toastText.textContent = message || "Copied!";
        toast.classList.add("show");

        // Reset SVG animation
        const svg = toast.querySelector("svg path");
        if (svg) {
          svg.style.animation = "none";
          svg.offsetHeight; // Trigger reflow
          svg.style.animation = "";
        }

        setTimeout(() => {
          toast.classList.remove("show");
        }, 1500);
      }

      // Load sample data
      function loadSampleData() {
        document.getElementById("jsonInput").value = JSON.stringify(
          sampleData,
          null,
          2
        );
        document.getElementById("successMsg").classList.remove("show");
        document.getElementById("errorMsg").classList.remove("show");
      }

      // Clear all
      function clearAll() {
        dataStore = [];
        currentData = null;
        activeId = null;
        isEditMode = false;
        hasUnsavedChanges = false;
        originalWorkbook = null;
        originalSheetName = null;
        deletedIds = new Set();
        selectedIds = new Set();
        columnHeaders = { id: "ID", content: "input" };
        clearStorage();
        document.getElementById("jsonInput").value = "";
        document.getElementById("textOutput").textContent =
          "Parse JSON to see plain text output here...";
        document.getElementById("textOutput").style.display = "block";
        document.getElementById("textOutputEditable").style.display = "none";
        document.getElementById("textOutputEditable").value = "";
        document.getElementById("editToggleBtn").classList.remove("active");
        document.getElementById("saveChangesBtn").style.display = "none";
        document.getElementById("editStatus").style.display = "none";
        document.getElementById("downloadExcelBtn").style.display = "none";
        // Reset select button
        document.getElementById("selectToggleBtn").classList.remove("selected");
        document.getElementById("parsedOutput").innerHTML = `
                <div class="empty-state">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                    </svg>
                    <h3>No Content Yet</h3>
                    <p>Paste JSON in the input tab and click "Parse JSON"</p>
                </div>
            `;
        renderIdList();
        document.getElementById("errorMsg").classList.remove("show");
        document.getElementById("successMsg").classList.remove("show");

        // Hide file name display
        document.getElementById("fileNameDisplay").classList.remove("show");
        document.getElementById("fileNameText").textContent = "";

        // Reset file input
        document.getElementById("excelFileInput").value = "";
      }

      // Escape HTML
      function escapeHtml(text) {
        if (!text) return "";
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Handle Excel file upload
      function handleExcelUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Store the file name
        currentFileName = file.name;

        // Display file name in header
        document.getElementById("fileNameText").textContent = file.name;
        document.getElementById("fileNameDisplay").classList.add("show");

        const loadingOverlay = document.getElementById("loadingOverlay");
        const loadingProgress = document.getElementById("loadingProgress");

        loadingOverlay.classList.add("show");
        loadingProgress.textContent = "Reading file...";

        const reader = new FileReader();

        reader.onload = function (e) {
          try {
            loadingProgress.textContent = "Parsing Excel data...";

            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });

            // Store original workbook for smart update
            originalWorkbook = workbook;

            // Get first sheet
            const sheetName = workbook.SheetNames[0];
            originalSheetName = sheetName;
            const worksheet = workbook.Sheets[sheetName];

            // Extract actual column headers (Row 1)
            const range = XLSX.utils.decode_range(worksheet["!ref"] || "A1");
            const headers = [];
            for (let col = range.s.c; col <= range.e.c; col++) {
              const cellAddress = XLSX.utils.encode_cell({ r: 0, c: col });
              const cell = worksheet[cellAddress];
              headers.push(cell ? cell.v : `Column${col + 1}`);
            }

            // Set dynamic column headers (Column A = ID, Column B = Content)
            columnHeaders = {
              id: headers[0] || "ID",
              content: headers[1] || "input",
              all: headers, // Store all headers
            };
            console.log("Detected headers:", columnHeaders);

            // Convert to JSON
            const jsonData = XLSX.utils.sheet_to_json(worksheet);

            loadingProgress.textContent = `Found ${jsonData.length} rows. Processing...`;

            // Clear existing data
            dataStore = [];
            activeId = null;
            deletedIds = new Set();
            selectedIds = new Set();

            let successCount = 0;
            let errorCount = 0;

            // Process each row
            jsonData.forEach((row, index) => {
              // Use dynamic header for ID column (Column A)
              let id =
                row[columnHeaders.id] ||
                row.ID ||
                row.id ||
                row.Id ||
                index + 1;

              // Check if row has existing Status
              const existingStatus = row.Status || row.status || row.STATUS;
              if (existingStatus === "Selected") {
                selectedIds.add(id);
              }

              // Use dynamic header for content column (Column B)
              let jsonStr =
                row[columnHeaders.content] ||
                row.input ||
                row.Input ||
                row.INPUT ||
                row.json ||
                row.JSON ||
                row.Json ||
                row.content ||
                row.Content ||
                row.CONTENT ||
                row.data ||
                row.Data ||
                row.DATA;

              if (jsonStr) {
                try {
                  let parsedData;

                  // Handle different formats
                  if (typeof jsonStr === "object") {
                    // Already an object
                    parsedData = jsonStr;
                  } else if (typeof jsonStr === "string") {
                    // Clean the string first
                    let cleanStr = jsonStr.trim();

                    // Remove potential BOM or weird characters
                    cleanStr = cleanStr.replace(/^\uFEFF/, "");

                    // Try to parse
                    parsedData = JSON.parse(cleanStr);
                  } else {
                    throw new Error("Unknown data type");
                  }

                  // Debug: log first item to console
                  if (index === 0) {
                    console.log("First row data:", parsedData);
                    console.log("Keys:", Object.keys(parsedData));
                  }

                  // Get title for display - check multiple possible fields
                  let title =
                    parsedData.meta_title ||
                    parsedData.title ||
                    parsedData.meta?.title ||
                    (parsedData.taglines &&
                      Array.isArray(parsedData.taglines) &&
                      parsedData.taglines[0]) ||
                    (parsedData.meta_description &&
                      parsedData.meta_description.substring(0, 40)) ||
                    `Data #${id}`;

                  // Ensure title is a string
                  title = String(title);

                  dataStore.push({
                    id: id,
                    title:
                      title.substring(0, 40) + (title.length > 40 ? "..." : ""),
                    data: parsedData,
                    rowIndex: index + 2, // Excel row number (1-indexed, +1 for header)
                    modified: false,
                  });

                  successCount++;
                } catch (parseError) {
                  console.warn(
                    `Row ${index + 1}: Invalid JSON - ${parseError.message}`
                  );
                  console.warn("Raw data:", jsonStr);
                  errorCount++;
                }
              }

              // Update progress
              if ((index + 1) % 50 === 0 || index === jsonData.length - 1) {
                loadingProgress.textContent = `Processing row ${index + 1} of ${
                  jsonData.length
                }...`;
              }
            });

            // Render the ID list
            renderIdList();
            saveToStorage();

            // Hide loading
            loadingOverlay.classList.remove("show");

            // Show success message
            const successMsg = document.getElementById("successMsg");
            const successText = document.getElementById("successText");
            successText.textContent = `‚úÖ Loaded ${successCount} items from Excel!${
              errorCount > 0 ? ` (${errorCount} rows had invalid JSON)` : ""
            }`;
            successMsg.classList.add("show");
            setTimeout(() => successMsg.classList.remove("show"), 4000);

            // Show download button
            document.getElementById("downloadExcelBtn").style.display =
              "inline-flex";

            // Reset file input
            event.target.value = "";

            // Don't auto-select, let user click on an ID
            // Switch to input tab but user will click ID to see plain text
          } catch (error) {
            loadingOverlay.classList.remove("show");

            const errorMsg = document.getElementById("errorMsg");
            const errorText = document.getElementById("errorText");
            errorText.textContent =
              "Error reading Excel file: " + error.message;
            errorMsg.classList.add("show");

            event.target.value = "";
          }
        };

        reader.onerror = function () {
          loadingOverlay.classList.remove("show");

          const errorMsg = document.getElementById("errorMsg");
          const errorText = document.getElementById("errorText");
          errorText.textContent = "Error reading file. Please try again.";
          errorMsg.classList.add("show");

          event.target.value = "";
        };

        reader.readAsArrayBuffer(file);
      }

      // Download updated Excel file with smart update
      function downloadExcel() {
        if (dataStore.length === 0) {
          showToast("No data to download!");
          return;
        }

        try {
          let wb, ws;

          if (originalWorkbook && originalSheetName) {
            // Smart Update: Modify the original workbook
            wb = XLSX.utils.book_new();
            const originalWs = originalWorkbook.Sheets[originalSheetName];

            // Get all data from original sheet
            const originalData = XLSX.utils.sheet_to_json(originalWs, {
              header: 1,
            });
            const headers = originalData[0] || [];

            // Find or add Status column
            let statusColIndex = headers.findIndex(
              (h) => h && h.toString().toLowerCase() === "status"
            );
            if (statusColIndex === -1) {
              statusColIndex = headers.length;
              headers.push("Status");
            }

            // Find content column index
            const contentColIndex =
              headers.findIndex(
                (h) =>
                  h &&
                  h.toString().toLowerCase() ===
                    columnHeaders.content.toLowerCase()
              ) || 1;

            // Build updated data
            const updatedData = [headers];

            // Process original rows (skip header)
            for (let i = 1; i < originalData.length; i++) {
              const row = originalData[i];
              const rowId = row[0]; // Column A is ID

              // Skip deleted rows
              if (deletedIds.has(rowId)) {
                continue;
              }

              // Find matching item in dataStore
              const item = dataStore.find((d) => d.id == rowId);

              // Ensure row has enough columns
              while (row.length < headers.length) {
                row.push("");
              }

              if (item && item.modified) {
                // Update the content column with modified data
                row[contentColIndex] = JSON.stringify(item.data);
              }

              // Update Status column
              if (selectedIds.has(rowId)) {
                row[statusColIndex] = "Selected";
              }

              updatedData.push(row);
            }

            // Create worksheet from updated data
            ws = XLSX.utils.aoa_to_sheet(updatedData);

            // Preserve column widths from original if available
            if (originalWs["!cols"]) {
              ws["!cols"] = [...originalWs["!cols"]];
              // Add width for Status column if new
              if (ws["!cols"].length < headers.length) {
                ws["!cols"].push({ wch: 15 });
              }
            }
          } else {
            // Fallback: Create new file if no original
            const headers = [columnHeaders.id, columnHeaders.content, "Status"];
            const wsData = [headers];

            dataStore.forEach((item) => {
              if (!deletedIds.has(item.id)) {
                wsData.push([
                  item.id,
                  JSON.stringify(item.data),
                  selectedIds.has(item.id) ? "Selected" : "",
                ]);
              }
            });

            ws = XLSX.utils.aoa_to_sheet(wsData);
            ws["!cols"] = [{ wch: 10 }, { wch: 100 }, { wch: 15 }];
          }

          // Create workbook and add sheet
          wb = XLSX.utils.book_new();
          XLSX.utils.book_append_sheet(wb, ws, originalSheetName || "Data");

          // Generate filename with timestamp
          const now = new Date();
          const timestamp = now.toISOString().slice(0, 10).replace(/-/g, "");
          const filename = `updated_data_${timestamp}.xlsx`;

          // Download file
          XLSX.writeFile(wb, filename);

          const selectedCount = selectedIds.size;
          const deletedCount = deletedIds.size;
          showToast(
            `‚úÖ Downloaded! ${selectedCount} selected, ${deletedCount} deleted`
          );
        } catch (error) {
          console.error("Error downloading Excel:", error);
          showToast("Error creating Excel file: " + error.message);
        }
      }

      // Toggle select status for current item
      function toggleSelectStatus() {
        if (!activeId) {
          showToast("No item selected!");
          return;
        }

        const selectBtn = document.getElementById("selectToggleBtn");

        if (selectedIds.has(activeId)) {
          selectedIds.delete(activeId);
          selectBtn.classList.remove("selected");
          showToast("Item unselected");
        } else {
          selectedIds.add(activeId);
          selectBtn.classList.add("selected");
          showToast("Item marked as Selected!");
        }

        // Update sidebar
        renderIdList();
        saveToStorage();
      }

      // Delete current row
      function deleteCurrentRow() {
        if (!activeId) {
          showToast("No item selected!");
          return;
        }

        if (confirm(`Are you sure you want to delete item #${activeId}?`)) {
          deletedIds.add(activeId);

          // Move to next available item
          const currentIndex = dataStore.findIndex((d) => d.id == activeId);
          let nextItem = null;

          // Find next non-deleted item
          for (let i = currentIndex + 1; i < dataStore.length; i++) {
            if (!deletedIds.has(dataStore[i].id)) {
              nextItem = dataStore[i];
              break;
            }
          }
          // If no next, find previous
          if (!nextItem) {
            for (let i = currentIndex - 1; i >= 0; i--) {
              if (!deletedIds.has(dataStore[i].id)) {
                nextItem = dataStore[i];
                break;
              }
            }
          }

          renderIdList();
          saveToStorage();

          if (nextItem) {
            selectId(nextItem.id);
          } else {
            activeId = null;
            document.getElementById("textOutput").textContent =
              "No items remaining...";
          }

          showToast(`Item #${activeId} marked for deletion`);
        }
      }

      // Edit mode state
      let isEditMode = false;
      let originalText = "";
      let hasUnsavedChanges = false;

      // Toggle edit mode
      function toggleEditMode() {
        isEditMode = !isEditMode;
        const textOutput = document.getElementById("textOutput");
        const textEditable = document.getElementById("textOutputEditable");
        const editBtn = document.getElementById("editToggleBtn");
        const saveBtn = document.getElementById("saveChangesBtn");
        const editStatus = document.getElementById("editStatus");

        if (isEditMode) {
          // Switch to edit mode
          originalText = textOutput.textContent;
          textEditable.value = originalText;
          textOutput.style.display = "none";
          textEditable.style.display = "block";
          saveBtn.style.display = "inline-flex";
          saveBtn.disabled = false; // Enable save button when entering edit mode
          editBtn.classList.add("active");
          editStatus.textContent = "Editing...";
          editStatus.className = "edit-status editing";
          editStatus.style.display = "inline-block";
          textEditable.focus();
        } else {
          // Exit edit mode
          textOutput.style.display = "block";
          textEditable.style.display = "none";
          saveBtn.style.display = "none";
          saveBtn.disabled = true;
          editBtn.classList.remove("active");
          editStatus.style.display = "none";
          hasUnsavedChanges = false;
          textEditable.classList.remove("modified");
        }
      }

      // Debounce timer for live updates
      let liveUpdateTimer = null;

      // Track text edits and update JSON + Parsed View in real-time
      function onTextEdit() {
        const textEditable = document.getElementById("textOutputEditable");
        const saveBtn = document.getElementById("saveChangesBtn");
        const editStatus = document.getElementById("editStatus");

        hasUnsavedChanges = true;
        saveBtn.disabled = false;
        textEditable.classList.add("modified");

        // Show syncing indicator
        editStatus.textContent = "Syncing...";
        editStatus.className = "edit-status syncing";

        // Debounce the live update to avoid too many updates while typing fast
        clearTimeout(liveUpdateTimer);
        liveUpdateTimer = setTimeout(() => {
          updateJsonAndParsedViewFromPlainText();
          // Show editing status after sync
          editStatus.textContent = "Editing...";
          editStatus.className = "edit-status editing";
        }, 300); // 300ms delay for smoother performance
      }

      // Update JSON Input and Parsed View from Plain Text in real-time
      function updateJsonAndParsedViewFromPlainText() {
        if (!activeId) return;

        const textEditable = document.getElementById("textOutputEditable");
        const newText = textEditable.value;

        // Parse the text back to JSON
        const newData = parseTextToJSON(newText);

        // Update JSON input textarea (live update)
        document.getElementById("jsonInput").value = JSON.stringify(
          newData,
          null,
          2
        );

        // Update parsed view (live update)
        renderParsedContent(newData);

        // Update currentData for consistency
        currentData = newData;
      }

      // Parse plain text back to JSON structure
      function parseTextToJSON(text) {
        const lines = text.split("\n");
        const data = {};
        let currentSection = null;
        let currentContent = [];
        let inFAQ = false;
        let currentFAQ = null;
        let faqList = [];

        const sectionMapping = {
          "TAGLINES:": "taglines",
          "META TITLE:": "meta_title",
          "META DESCRIPTION:": "meta_description",
          "BENEFITS:": "benefits",
          "WHEN TO RECITE:": "when_to_recite",
          "HOW TO PERFORM:": "how_to_perform",
          "SUMMARY:": "summary",
          "FREQUENTLY ASKED QUESTIONS:": "faqs",
        };

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();

          // Check for section headers
          let foundSection = null;
          for (const [header, section] of Object.entries(sectionMapping)) {
            if (line === header || line.startsWith(header)) {
              foundSection = section;
              break;
            }
          }

          if (foundSection) {
            // Save previous section
            if (currentSection && currentContent.length > 0) {
              saveSectionData(data, currentSection, currentContent, faqList);
            }

            currentSection = foundSection;
            currentContent = [];
            inFAQ = foundSection === "faqs";
            faqList = [];
            currentFAQ = null;
            continue;
          }

          // Handle FAQ format
          if (inFAQ && currentSection === "faqs") {
            if (line.match(/^Q\d+:/)) {
              if (currentFAQ && currentFAQ.question) {
                faqList.push(currentFAQ);
              }
              currentFAQ = {
                question: line.replace(/^Q\d+:\s*/, ""),
                answer: "",
              };
            } else if (line.match(/^A\d+:/) && currentFAQ) {
              currentFAQ.answer = line.replace(/^A\d+:\s*/, "");
            } else if (line && currentFAQ && !currentFAQ.answer) {
              currentFAQ.question += " " + line;
            } else if (line && currentFAQ && currentFAQ.answer) {
              currentFAQ.answer += " " + line;
            }
          } else if (line) {
            currentContent.push(line);
          }
        }

        // Save last section
        if (
          currentSection &&
          (currentContent.length > 0 || faqList.length > 0 || currentFAQ)
        ) {
          if (currentFAQ && currentFAQ.question) {
            faqList.push(currentFAQ);
          }
          saveSectionData(data, currentSection, currentContent, faqList);
        }

        return data;
      }

      // Helper to save section data in proper format
      function saveSectionData(data, section, content, faqList) {
        switch (section) {
          case "taglines":
            // Taglines are comma-separated
            if (content.length > 0) {
              data.taglines = content[0]
                .split(",")
                .map((t) => t.trim())
                .filter((t) => t);
            }
            break;
          case "meta_title":
            data.meta_title = content.join(" ");
            break;
          case "meta_description":
            data.meta_description = content.join(" ");
            break;
          case "benefits":
          case "when_to_recite":
          case "how_to_perform":
            // Find title, subtitle, and numbered content
            let title = "";
            let subtitle = "";
            let items = [];

            for (const line of content) {
              if (line.match(/^\d+\./)) {
                items.push(line.replace(/^\d+\.\s*/, ""));
              } else if (!title) {
                title = line;
              } else if (!subtitle) {
                subtitle = line;
              }
            }

            data[section] = {
              title: title,
              subtitle: subtitle,
              content: items,
            };
            break;
          case "summary":
            data.summary = content;
            break;
          case "faqs":
            data.faqs = faqList;
            break;
        }
      }

      // Save text changes back to data
      function saveTextChanges() {
        if (!activeId) {
          showToast("No item selected to save!");
          return;
        }

        const textEditable = document.getElementById("textOutputEditable");
        const newText = textEditable.value;

        // Find the item in dataStore
        const itemIndex = dataStore.findIndex((d) => d.id == activeId);
        if (itemIndex === -1) {
          showToast("Item not found in data store!");
          return;
        }

        // Parse the text back to JSON
        const newData = parseTextToJSON(newText);

        // Update the dataStore
        dataStore[itemIndex].data = newData;
        dataStore[itemIndex].modified = true; // Mark as modified for smart update
        currentData = newData;

        // Update title if meta_title changed
        if (newData.meta_title) {
          const title = newData.meta_title;
          dataStore[itemIndex].title =
            title.substring(0, 40) + (title.length > 40 ? "..." : "");
        }

        // Update JSON input
        document.getElementById("jsonInput").value = JSON.stringify(
          newData,
          null,
          2
        );

        // Update parsed view
        renderParsedContent(newData);

        // Update text output (non-editable version)
        document.getElementById("textOutput").textContent = newText;
        originalText = newText;

        // Save to IndexedDB
        saveToStorage();

        // Re-render sidebar
        renderIdList();

        // Update UI - Exit edit mode after save
        hasUnsavedChanges = false;
        textEditable.classList.remove("modified");

        // Show saved status
        const editStatus = document.getElementById("editStatus");
        editStatus.textContent = "Saved!";
        editStatus.className = "edit-status saved";

        showToast("‚úÖ Changes saved!");

        // Hide editing status and exit edit mode after 1.5 seconds
        setTimeout(() => {
          // Exit edit mode
          isEditMode = false;
          document.getElementById("textOutput").style.display = "block";
          textEditable.style.display = "none";
          document.getElementById("saveChangesBtn").style.display = "none";
          document.getElementById("editToggleBtn").classList.remove("active");
          editStatus.style.display = "none"; // Hide the editing status
        }, 1500);
      }

      // Keyboard shortcuts
      document.addEventListener("keydown", function (e) {
        if (e.ctrlKey && e.key === "Enter") {
          parseJSON();
        }
        // Ctrl+S to save in edit mode
        if (e.ctrlKey && e.key === "s" && isEditMode && hasUnsavedChanges) {
          e.preventDefault();
          saveTextChanges();
        }
      });

      // Initialize
      document.addEventListener("DOMContentLoaded", async function () {
        await openDatabase();
        await loadFromStorage();
        renderIdList();
        console.log("Initialization complete, items:", dataStore.length);
      });
    </script>
  </body>
</html>
